- ([x] [x y] [x y & more])
* ([] [x] [x y] [x y & more])
*1
*2
*3
*agent*
*allow-unresolved-vars*
*clojure-version*
*command-line-args*
*compile-files*
*compile-path*
*current*
*e
*err*
*file*
*flush-on-newline*
*in*
*macro-meta*
*math-context*
*ns*
*out*
*print-dup*
*print-length*
*print-level*
*print-meta*
*print-readably*
*read-eval*
*sb*
*source-path*
*stack*
*state*
*use-context-classloader*
*warn-on-reflection*
.. ([x form] [x form & more])
/ ([x] [x y] [x y & more])
+ ([] [x] [x y] [x y & more])
< ([x] [x y] [x y & more])
<= ([x] [x y] [x y & more])
= ([x] [x y] [x y & more])
== ([x] [x y] [x y & more])
-> ([x form] [x form & more])
> ([x] [x y] [x y & more])
>= ([x] [x y] [x y & more])
accessor ([s key])
aclone ([array])
add-classpath ([url])
add-watch ([reference key fn])
add-watcher ([reference send-type watcher-agent action-fn])
agent ([state] [state & options])
agent-errors ([a])
aget ([array idx] [array idx & idxs])
alength ([array])
alias ([alias namespace-sym])
all-ns ([])
alter ([ref fun & args])
alter-meta! ([iref f & args])
alter-var-root ([v f & args])
amap ([a idx ret expr])
ancestors ([tag] [h tag])
and ([] [x] [x & next])
append-child ([loc item])
apply ([f args* argseq])
areduce ([a idx ret init expr])
array-map ([] [& keyvals])
aset ([array idx val] [array idx idx2 & idxv])
aset-boolean ([array idx val] [array idx idx2 & idxv])
aset-byte ([array idx val] [array idx idx2 & idxv])
aset-char ([array idx val] [array idx idx2 & idxv])
aset-double ([array idx val] [array idx idx2 & idxv])
aset-float ([array idx val] [array idx idx2 & idxv])
aset-int ([array idx val] [array idx idx2 & idxv])
aset-long ([array idx val] [array idx idx2 & idxv])
aset-short ([array idx val] [array idx idx2 & idxv])
assert ([x])
assoc ([map key val] [map key val & kvs])
associative? ([coll])
assoc-in ([m [k & ks] v])
atom ([x] [x & options])
attrs
await ([& agents])
await1 ([a])
await-for ([timeout-ms & agents])
bases ([c])
bean ([x])
bigdec ([x])
bigint ([x])
binding ([bindings & body])
bit-and ([x y])
bit-and-not ([x y])
bit-clear ([x n])
bit-flip ([x n])
bit-not ([x])
bit-or ([x y])
bit-set ([x n])
bit-shift-left ([x n])
bit-shift-right ([x n])
bit-test ([x n])
bit-xor ([x y])
boolean ([x])
branch? ([loc])
butlast ([coll])
byte ([x])
cast ([c x])
char ([x])
char-escape-string
char-name-string
children ([loc])
class ([x])
class? ([x])
clear-agent-errors ([a])
clojure-version ([])
coll? ([x])
comment ([& body])
commute ([ref fun & args])
comp ([& fs])
comparator ([pred])
compare ([x y])
compare-and-set! ([atom oldval newval])
compile ([lib])
complement ([f])
concat ([] [x] [x y] [x y & zs])
cond ([& clauses])
condp ([pred expr & clauses])
conj ([coll x] [coll x & xs])
cons ([x seq])
constantly ([x])
construct-proxy ([c & ctor-args])
contains? ([coll key])
content
content-handler
count ([coll])
counted? ([coll])
create-ns ([sym])
create-struct ([& keys])
cycle ([coll])
dec ([x])
decimal? ([n])
declare ([& names])
definline ([name & decl])
defmacro ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])
defmethod ([multifn dispatch-val & fn-tail])
defmulti ([name docstring? attr-map? dispatch-fn & options])
defn- ([name & decls])
defn ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])
defonce ([name expr])
defstruct ([name & keys])
delay ([& body])
delay? ([x])
deref ([ref])
derive ([tag parent] [h tag parent])
descendants ([tag] [h tag])
destructure ([bindings])
difference ([s1] [s1 s2] [s1 s2 & sets])
disj ([set] [set key] [set key & ks])
dissoc ([map] [map key] [map key & ks])
distinct ([coll])
distinct? ([x] [x y] [x y & more])
doall ([coll] [n coll])
doc ([name])
dorun ([coll] [n coll])
doseq ([seq-exprs & body])
dosync ([& exprs])
dotimes ([bindings & body])
doto ([x & forms])
double ([x])
double-array ([size-or-seq] [size init-val-or-seq])
doubles ([xs])
down ([loc])
drop ([n coll])
drop-last ([s] [n s])
drop-while ([pred coll])
edit ([loc f & args])
element
emit ([x])
emit-element ([e])
empty ([coll])
empty? ([coll])
end? ([loc])
ensure ([ref])
enumeration-seq ([e])
eval ([form])
even? ([n])
every? ([pred coll])
false? ([x])
ffirst ([x])
file-seq ([dir])
filter ([pred coll])
find ([map key])
find-doc ([re-string-or-pattern])
find-ns ([sym])
find-var ([sym])
first ([coll])
float ([x])
float? ([n])
float-array ([size-or-seq] [size init-val-or-seq])
floats ([xs])
flush ([])
fn ([& sigs])
fn? ([x])
fnext ([x])
for ([seq-exprs body-expr])
force ([x])
format ([fmt & args])
future ([& body])
future-call ([f])
gen-class ([& options])
gen-interface ([& options])
gensym ([] [prefix-string])
get ([map key] [map key not-found])
get-in ([m ks])
get-method ([multifn dispatch-val])
get-proxy-class ([& bases])
get-validator ([iref])
hash ([x])
hash-map ([] [& keyvals])
hash-set ([] [& keys])
identical? ([x y])
identity ([x])
if-let ([bindings then] [bindings then else & oldform])
ifn? ([x])
if-not ([test then] [test then else])
import ([& import-symbols-or-lists])
inc ([x])
index ([xrel ks])
init-proxy ([proxy mappings])
in-ns ([name])
insert-child ([loc item])
insert-left ([loc item])
insert-right ([loc item])
instance? ([c x])
int ([x])
int-array ([size-or-seq] [size init-val-or-seq])
integer? ([n])
interleave ([& colls])
intern ([ns name] [ns name val])
interpose ([sep coll])
intersection ([s1] [s1 s2] [s1 s2 & sets])
into ([to from])
into-array ([aseq] [type aseq])
ints ([xs])
io! ([& body])
isa? ([child parent] [h child parent])
iterate ([f x])
iterator-seq ([iter])
join ([xrel yrel] [xrel yrel km])
key ([e])
keys ([map])
keyword ([name] [ns name])
keyword? ([x])
last ([coll])
lazy-cat ([& colls])
lazy-seq ([& body])
left ([loc])
leftmost ([loc])
lefts ([loc])
let ([bindings & body])
letfn ([fnspecs & body])
line-seq ([rdr])
list ([& items])
list* ([item & more])
list? ([x])
load ([& paths])
loaded-libs ([])
load-file ([name])
load-reader ([rdr])
load-script ([path])
load-string ([s])
locking ([x & body])
long ([x])
long-array ([size-or-seq] [size init-val-or-seq])
longs ([xs])
loop ([bindings & body])
macroexpand ([form])
macroexpand-1 ([form])
main ([& args])
make-array ([type len] [type dim & more-dims])
make-hierarchy ([])
make-node ([loc node children])
map ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])
map? ([x])
mapcat ([f & colls])
map-invert ([m])
max ([x] [x y] [x y & more])
max-key ([k x] [k x y] [k x y & more])
memfn ([name & args])
memoize ([f])
merge ([& maps])
merge-with ([f & maps])
meta ([obj])
methods ([multifn])
method-sig ([meth])
min ([x] [x y] [x y & more])
min-key ([k x] [k x y] [k x y & more])
mod ([num div])
name ([x])
namespace ([x])
neg? ([x])
newline ([])
next ([coll])
next ([loc])
nfirst ([x])
nil? ([x])
nnext ([x])
node ([loc])
not ([x])
not= ([x] [x y] [x y & more])
not-any? ([pred coll])
not-empty ([coll])
not-every? ([pred coll])
ns ([name & references])
ns-aliases ([ns])
ns-imports ([ns])
ns-interns ([ns])
ns-map ([ns])
ns-name ([ns])
ns-publics ([ns])
ns-refers ([ns])
ns-resolve ([ns sym])
ns-unalias ([ns sym])
ns-unmap ([ns sym])
nth ([coll index] [coll index not-found])
nthnext ([coll n])
num ([x])
number? ([x])
odd? ([n])
or ([] [x] [x & next])
parents ([tag] [h tag])
parse ([s] [s startparse])
partial ([f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])
partition ([n coll] [n step coll])
path ([loc])
pcalls ([& fns])
peek ([coll])
pmap ([f coll] [f coll & colls])
pop ([coll])
pos? ([x])
pr ([] [x] [x & more])
prefer-method ([multifn dispatch-val-x dispatch-val-y])
prefers ([multifn])
prev ([loc])
primitives-classnames
print ([& more])
print-ctor ([o print-args w])
print-doc ([v])
print-dup
printf ([fmt & args])
println ([& more])
println-str ([& xs])
print-method
print-namespace-doc ([nspace])
print-simple ([o w])
print-special-doc ([name type anchor])
print-str ([& xs])
prn ([& more])
prn-str ([& xs])
project ([xrel ks])
proxy ([class-and-interfaces args & fs])
proxy-call-with-super ([call this meth])
proxy-mappings ([proxy])
proxy-name ([super interfaces])
proxy-super ([meth & args])
pr-str ([& xs])
pvalues ([& exprs])
quot ([num div])
rand ([] [n])
rand-int ([n])
range ([end] [start end] [start end step])
ratio? ([n])
rational? ([n])
rationalize ([num])
read ([] [stream] [stream eof-error? eof-value] [stream eof-error? eof-value recursive?])
read-line ([])
read-string ([s])
reduce ([f coll] [f val coll])
ref ([x] [x & options])
refer ([ns-sym & filters])
refer-clojure ([& filters])
re-find ([m] [re s])
ref-set ([ref val])
re-groups ([m])
release-pending-sends ([])
rem ([num div])
re-matcher ([re s])
re-matches ([re s])
remove ([loc])
remove ([pred coll])
remove-method ([multifn dispatch-val])
remove-ns ([sym])
remove-watch ([reference key])
remove-watcher ([reference watcher-agent])
rename ([xrel kmap])
rename-keys ([map kmap])
re-pattern ([s])
repeat ([x] [n x])
repeatedly ([f])
repl ([& options])
replace ([loc node])
replace ([smap coll])
repl-caught ([e])
repl-exception ([throwable])
replicate ([n x])
repl-prompt ([])
repl-read ([request-prompt request-exit])
require ([& args])
re-seq ([re s])
reset! ([atom newval])
reset-meta! ([iref metadata-map])
resolve ([sym])
rest ([coll])
resultset-seq ([rs])
reverse ([coll])
reversible? ([coll])
right ([loc])
rightmost ([loc])
rights ([loc])
root ([loc])
rseq ([rev])
rsubseq ([sc test key] [sc start-test start-key end-test end-key])
second ([x])
select ([pred xset])
select-keys ([map keyseq])
send ([a f & args])
send-off ([a f & args])
seq ([coll])
seq? ([x])
seque ([s] [n-or-q s])
sequence ([coll])
sequential? ([coll])
seq-zip ([root])
set ([coll])
set? ([x])
set-validator! ([iref validator-fn])
short ([x])
shutdown-agents ([])
skip-if-eol ([s])
skip-whitespace ([s])
slurp ([f])
some ([pred coll])
sort ([coll] [comp coll])
sort-by ([keyfn coll] [keyfn comp coll])
sorted? ([coll])
sorted-map ([& keyvals])
sorted-map-by ([comparator & keyvals])
sorted-set ([& keys])
special-form-anchor ([x])
special-symbol? ([s])
split-at ([n coll])
split-with ([pred coll])
startparse-sax ([s ch])
str ([] [x] [x & ys])
stream? ([x])
string? ([x])
struct ([s & vals])
struct-map ([s & inits])
subs ([s start] [s start end])
subseq ([sc test key] [sc start-test start-key end-test end-key])
subvec ([v start] [v start end])
supers ([class])
swap! ([atom f] [atom f x] [atom f x y] [atom f x y & args])
symbol ([name] [ns name])
symbol? ([x])
sync ([flags-ignored-for-now & body])
syntax-symbol-anchor ([x])
tag
take ([n coll])
take-nth ([n coll])
take-while ([pred coll])
test ([v])
the-ns ([x])
time ([expr])
to-array ([coll])
to-array-2d ([coll])
trampoline ([f] [f & args])
tree-seq ([branch? children root])
true? ([x])
type ([x])
unchecked-add ([x y])
unchecked-dec ([x])
unchecked-divide ([x y])
unchecked-inc ([x])
unchecked-multiply ([x y])
unchecked-negate ([x])
unchecked-remainder ([x y])
unchecked-subtract ([x y])
underive ([tag parent] [h tag parent])
union ([] [s1] [s1 s2] [s1 s2 & sets])
unquote
unquote-splicing
up ([loc])
update-in ([m [k & ks] f & args])
update-proxy ([proxy mappings])
use ([& args])
val ([e])
vals ([map])
var? ([v])
var-get ([x])
var-set ([x val])
vary-meta ([obj f & args])
vec ([coll])
vector ([] [& args])
vector? ([x])
vector-zip ([root])
when ([test & body])
when-first ([bindings & body])
when-let ([bindings & body])
when-not ([test & body])
while ([test & body])
with-bindings ([& body])
with-in-str ([s & body])
with-local-vars ([name-vals-vec & body])
with-meta ([obj m])
with-open ([bindings & body])
with-out-str ([& body])
with-precision ([precision & exprs])
xml-seq ([root])
xml-zip ([root])
zero? ([x])
zipmap ([keys vals])
zipper ([branch? children make-node root])
